<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main.cpp" />
              <option name="originalContent" value="/* Using LVGL with Arduino requires some extra steps...&#10; *&#10; * Be sure to read the docs here: https://docs.lvgl.io/master/integration/framework/arduino.html&#10; * but note you should use the lv_conf.h from the repo as it is pre-edited to work.&#10; *&#10; * You can always edit your own lv_conf.h later and exclude the example options once the build environment is working.&#10; *&#10; * Note you MUST move the 'examples' and 'demos' folders into the 'src' folder inside the lvgl library folder&#10; * otherwise this will not compile, please see README.md in the repo.&#10; *&#10; */&#10;#include &lt;Arduino.h&gt;&#10;#include &lt;lvgl.h&gt;&#10;#include &lt;TFT_eSPI.h&gt;&#10;#include &lt;XPT2046_Touchscreen.h&gt;&#10;#include &lt;SD.h&gt;&#10;#include &lt;FS.h&gt;&#10;&#10;// A library for interfacing with the touch screen&#10;//&#10;// Can be installed from the library manager (Search for &quot;XPT2046&quot;)&#10;//https://github.com/PaulStoffregen/XPT2046_Touchscreen&#10;// ----------------------------&#10;// Touch Screen pins&#10;// ----------------------------&#10;&#10;// The CYD touch uses some non default&#10;// SPI pins&#10;&#10;#define XPT2046_IRQ 36&#10;#define XPT2046_MOSI 32&#10;#define XPT2046_MISO 39&#10;#define XPT2046_CLK 25&#10;#define XPT2046_CS 33&#10;&#10;// SD Card pin for ESP32-2432S028R&#10;#define SD_CS 5&#10;&#10;SPIClass touchscreenSpi = SPIClass(VSPI);&#10;XPT2046_Touchscreen touchscreen(XPT2046_CS, XPT2046_IRQ);&#10;uint16_t touchScreenMinimumX = 200, touchScreenMaximumX = 3700, touchScreenMinimumY = 240, touchScreenMaximumY = 3800;&#10;&#10;/*Set to your screen resolution*/&#10;#define TFT_HOR_RES   320&#10;#define TFT_VER_RES   240&#10;&#10;/*LVGL draw into this buffer, 1/10 screen size usually works well. The size is in bytes*/&#10;#define DRAW_BUF_SIZE (TFT_HOR_RES * TFT_VER_RES / 10 * (LV_COLOR_DEPTH / 8))&#10;&#10;#if LV_USE_LOG != 0&#10;void my_print( lv_log_level_t level, const char * buf )&#10;{&#10;    LV_UNUSED(level);&#10;    Serial.println(buf);&#10;    Serial.flush();&#10;}&#10;#endif&#10;&#10;/* LVGL calls it when a rendered image needs to copied to the display*/&#10;void my_disp_flush(lv_display_t *disp, const lv_area_t *area, uint8_t *px_map) {&#10;    /*Call it to tell LVGL you are ready*/&#10;    lv_disp_flush_ready(disp);&#10;}&#10;&#10;/*Read the touchpad*/&#10;void my_touchpad_read(lv_indev_t *indev, lv_indev_data_t *data) {&#10;    if (touchscreen.touched()) {&#10;        TS_Point p = touchscreen.getPoint();&#10;        //Some very basic auto calibration so it doesn't go out of range&#10;        if (p.x &lt; touchScreenMinimumX) touchScreenMinimumX = p.x;&#10;        if (p.x &gt; touchScreenMaximumX) touchScreenMaximumX = p.x;&#10;        if (p.y &lt; touchScreenMinimumY) touchScreenMinimumY = p.y;&#10;        if (p.y &gt; touchScreenMaximumY) touchScreenMaximumY = p.y;&#10;        //Map this to the pixel position&#10;        data-&gt;point.x = map(p.x, touchScreenMinimumX, touchScreenMaximumX, 1,TFT_HOR_RES);&#10;        /* Touchscreen X calibration */&#10;        data-&gt;point.y = map(p.y, touchScreenMinimumY, touchScreenMaximumY, 1,TFT_VER_RES);&#10;        /* Touchscreen Y calibration */&#10;        data-&gt;state = LV_INDEV_STATE_PRESSED;&#10;        /*&#10;        Serial.print(&quot;Touch x &quot;);&#10;        Serial.print(data-&gt;point.x);&#10;        Serial.print(&quot; y &quot;);&#10;        Serial.println(data-&gt;point.y);&#10;        */&#10;    } else {&#10;        data-&gt;state = LV_INDEV_STATE_RELEASED;&#10;    }&#10;}&#10;&#10;lv_indev_t *indev; //Touchscreen input device&#10;uint8_t *draw_buf; //draw_buf is allocated on heap otherwise the static area is too big on ESP32 at compile&#10;uint32_t lastTick = 0; //Used to track the tick timer&#10;&#10;// Global variables for file list&#10;lv_obj_t * file_list;&#10;String fileNames[50]; // Store up to 50 files&#10;int fileCount = 0;&#10;&#10;// Function to scan SD card root directory for files&#10;void scanSDCard() {&#10;    fileCount = 0;&#10;&#10;    // Initialize SD card using VSPI (same as the working example)&#10;    SPIClass spi = SPIClass(VSPI);&#10;&#10;    if (!SD.begin(SS, spi, 80000000)) {&#10;        Serial.println(&quot;SD Card initialization failed!&quot;);&#10;        fileNames[0] = &quot;SD Card Error&quot;;&#10;        fileCount = 1;&#10;        return;&#10;    }&#10;&#10;    Serial.println(&quot;SD Card initialized successfully&quot;);&#10;&#10;    // Check card type&#10;    uint8_t cardType = SD.cardType();&#10;    if (cardType == CARD_NONE) {&#10;        Serial.println(&quot;No SD card attached&quot;);&#10;        fileNames[0] = &quot;No SD Card&quot;;&#10;        fileCount = 1;&#10;        return;&#10;    }&#10;&#10;    // Open root directory&#10;    File root = SD.open(&quot;/&quot;);&#10;    if (!root) {&#10;        Serial.println(&quot;Failed to open root directory&quot;);&#10;        fileNames[0] = &quot;Directory Error&quot;;&#10;        fileCount = 1;&#10;        return;&#10;    }&#10;&#10;    // Scan files in root directory&#10;    File file = root.openNextFile();&#10;    while (file &amp;&amp; fileCount &lt; 50) {&#10;        if (!file.isDirectory()) {&#10;            fileNames[fileCount] = String(file.name());&#10;            Serial.println(&quot;Found file: &quot; + fileNames[fileCount]);&#10;            fileCount++;&#10;        }&#10;        file = root.openNextFile();&#10;    }&#10;&#10;    if (fileCount == 0) {&#10;        fileNames[0] = &quot;No files found&quot;;&#10;        fileCount = 1;&#10;    }&#10;&#10;    root.close();&#10;}&#10;&#10;// Event handler for file list items&#10;static void file_list_event_handler(lv_event_t * e) {&#10;    lv_event_code_t code = lv_event_get_code(e);&#10;    lv_obj_t * obj = lv_event_get_target_obj(e);&#10;&#10;    if (code == LV_EVENT_CLICKED) {&#10;        // Get the label from the button and extract filename&#10;        lv_obj_t * label = lv_obj_get_child(obj, 0);&#10;        const char * txt = lv_label_get_text(label);&#10;        Serial.println(&quot;Selected file: &quot; + String(txt));&#10;&#10;        // Here you can add code to handle the selected file&#10;        // For example, play audio file, open file, etc.&#10;    }&#10;}&#10;&#10;void setup() {&#10;    //Some basic info on the Serial console&#10;    Serial.begin(115200);&#10;&#10;    //Initialise the touchscreen&#10;    touchscreenSpi.begin(XPT2046_CLK, XPT2046_MISO, XPT2046_MOSI, XPT2046_CS);&#10;    /* Start second SPI bus for touchscreen */&#10;    touchscreen.begin(touchscreenSpi); /* Touchscreen init */&#10;    touchscreen.setRotation(3); /* Inverted landscape orientation to match screen */&#10;&#10;    //Initialise LVGL&#10;    lv_init();&#10;    draw_buf = new uint8_t[DRAW_BUF_SIZE];&#10;    lv_display_t *disp;&#10;    disp = lv_tft_espi_create(TFT_HOR_RES, TFT_VER_RES, draw_buf, DRAW_BUF_SIZE);&#10;&#10;    //Initialize the XPT2046 input device driver&#10;    indev = lv_indev_create();&#10;    lv_indev_set_type(indev, LV_INDEV_TYPE_POINTER);&#10;    lv_indev_set_read_cb(indev, my_touchpad_read);&#10;&#10;    // Scan SD card for files&#10;    scanSDCard();&#10;&#10;    // Create a scrollable container instead of a list&#10;    file_list = lv_obj_create(lv_screen_active());&#10;    lv_obj_set_size(file_list, 300, 220);  // Set container size to fit screen&#10;    lv_obj_center(file_list);              // Center the container on screen&#10;&#10;    // Enable scrolling&#10;    lv_obj_set_scroll_dir(file_list, LV_DIR_VER);&#10;    lv_obj_set_scrollbar_mode(file_list, LV_SCROLLBAR_MODE_AUTO);&#10;    lv_obj_add_flag(file_list, LV_OBJ_FLAG_SCROLL_ELASTIC);&#10;&#10;    // Set flex layout for vertical arrangement&#10;    lv_obj_set_flex_flow(file_list, LV_FLEX_FLOW_COLUMN);&#10;    lv_obj_set_flex_align(file_list, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);&#10;&#10;    // Add files as individual buttons&#10;    for (int i = 0; i &lt; fileCount; i++) {&#10;        lv_obj_t * btn = lv_button_create(file_list);&#10;        lv_obj_set_size(btn, 280, 40);  // Button size&#10;        lv_obj_add_event_cb(btn, file_list_event_handler, LV_EVENT_ALL, nullptr);&#10;&#10;        // Create label for the file name&#10;        lv_obj_t * label = lv_label_create(btn);&#10;        lv_label_set_text_fmt(label, LV_SYMBOL_FILE &quot; %s&quot;, fileNames[i].c_str());&#10;        lv_obj_center(label);&#10;    }&#10;&#10;    //Done&#10;    Serial.println(&quot;Setup done&quot;);&#10;}&#10;&#10;void loop() {&#10;    lv_tick_inc(millis() - lastTick); //Update the tick timer. Tick is new for LVGL 9&#10;    lastTick = millis();&#10;    lv_timer_handler(); //Update the UI&#10;    delay(5);&#10;}" />
              <option name="updatedContent" value="/* Using LVGL with Arduino requires some extra steps...&#10; *&#10; * Be sure to read the docs here: https://docs.lvgl.io/master/integration/framework/arduino.html&#10; * but note you should use the lv_conf.h from the repo as it is pre-edited to work.&#10; *&#10; * You can always edit your own lv_conf.h later and exclude the example options once the build environment is working.&#10; *&#10; * Note you MUST move the 'examples' and 'demos' folders into the 'src' folder inside the lvgl library folder&#10; * otherwise this will not compile, please see README.md in the repo.&#10; *&#10; */&#10;#include &lt;Arduino.h&gt;&#10;#include &lt;lvgl.h&gt;&#10;#include &lt;TFT_eSPI.h&gt;&#10;#include &lt;XPT2046_Touchscreen.h&gt;&#10;#include &lt;SD.h&gt;&#10;#include &lt;FS.h&gt;&#10;&#10;// A library for interfacing with the touch screen&#10;//&#10;// Can be installed from the library manager (Search for &quot;XPT2046&quot;)&#10;//https://github.com/PaulStoffregen/XPT2046_Touchscreen&#10;// ----------------------------&#10;// Touch Screen pins&#10;// ----------------------------&#10;&#10;// The CYD touch uses some non default&#10;// SPI pins&#10;&#10;#define XPT2046_IRQ 36&#10;#define XPT2046_MOSI 32&#10;#define XPT2046_MISO 39&#10;#define XPT2046_CLK 25&#10;#define XPT2046_CS 33&#10;&#10;// SD Card pin for ESP32-2432S028R&#10;#define SD_CS 5&#10;&#10;SPIClass touchscreenSpi = SPIClass(VSPI);&#10;XPT2046_Touchscreen touchscreen(XPT2046_CS, XPT2046_IRQ);&#10;uint16_t touchScreenMinimumX = 200, touchScreenMaximumX = 3700, touchScreenMinimumY = 240, touchScreenMaximumY = 3800;&#10;&#10;/*Set to your screen resolution*/&#10;#define TFT_HOR_RES   320&#10;#define TFT_VER_RES   240&#10;&#10;/*LVGL draw into this buffer, 1/10 screen size usually works well. The size is in bytes*/&#10;#define DRAW_BUF_SIZE (TFT_HOR_RES * TFT_VER_RES / 10 * (LV_COLOR_DEPTH / 8))&#10;&#10;#if LV_USE_LOG != 0&#10;void my_print( lv_log_level_t level, const char * buf )&#10;{&#10;    LV_UNUSED(level);&#10;    Serial.println(buf);&#10;    Serial.flush();&#10;}&#10;#endif&#10;&#10;/* LVGL calls it when a rendered image needs to copied to the display*/&#10;void my_disp_flush(lv_display_t *disp, const lv_area_t *area, uint8_t *px_map) {&#10;    /*Call it to tell LVGL you are ready*/&#10;    lv_disp_flush_ready(disp);&#10;}&#10;&#10;/*Read the touchpad*/&#10;void my_touchpad_read(lv_indev_t *indev, lv_indev_data_t *data) {&#10;    if (touchscreen.touched()) {&#10;        TS_Point p = touchscreen.getPoint();&#10;        //Some very basic auto calibration so it doesn't go out of range&#10;        if (p.x &lt; touchScreenMinimumX) touchScreenMinimumX = p.x;&#10;        if (p.x &gt; touchScreenMaximumX) touchScreenMaximumX = p.x;&#10;        if (p.y &lt; touchScreenMinimumY) touchScreenMinimumY = p.y;&#10;        if (p.y &gt; touchScreenMaximumY) touchScreenMaximumY = p.y;&#10;        //Map this to the pixel position&#10;        data-&gt;point.x = map(p.x, touchScreenMinimumX, touchScreenMaximumX, 1,TFT_HOR_RES);&#10;        /* Touchscreen X calibration */&#10;        data-&gt;point.y = map(p.y, touchScreenMinimumY, touchScreenMaximumY, 1,TFT_VER_RES);&#10;        /* Touchscreen Y calibration */&#10;        data-&gt;state = LV_INDEV_STATE_PRESSED;&#10;        /*&#10;        Serial.print(&quot;Touch x &quot;);&#10;        Serial.print(data-&gt;point.x);&#10;        Serial.print(&quot; y &quot;);&#10;        Serial.println(data-&gt;point.y);&#10;        */&#10;    } else {&#10;        data-&gt;state = LV_INDEV_STATE_RELEASED;&#10;    }&#10;}&#10;&#10;lv_indev_t *indev; //Touchscreen input device&#10;uint8_t *draw_buf; //draw_buf is allocated on heap otherwise the static area is too big on ESP32 at compile&#10;uint32_t lastTick = 0; //Used to track the tick timer&#10;&#10;// Global variables for file list&#10;lv_obj_t * file_list;&#10;String fileNames[50]; // Store up to 50 files&#10;int fileCount = 0;&#10;&#10;// Function to scan SD card root directory for files&#10;void scanSDCard() {&#10;    fileCount = 0;&#10;&#10;    // Initialize SD card using VSPI (same as the working example)&#10;    SPIClass spi = SPIClass(VSPI);&#10;&#10;    if (!SD.begin(SS, spi, 80000000)) {&#10;        Serial.println(&quot;SD Card initialization failed!&quot;);&#10;        fileNames[0] = &quot;SD Card Error&quot;;&#10;        fileCount = 1;&#10;        return;&#10;    }&#10;&#10;    Serial.println(&quot;SD Card initialized successfully&quot;);&#10;&#10;    // Check card type&#10;    uint8_t cardType = SD.cardType();&#10;    if (cardType == CARD_NONE) {&#10;        Serial.println(&quot;No SD card attached&quot;);&#10;        fileNames[0] = &quot;No SD Card&quot;;&#10;        fileCount = 1;&#10;        return;&#10;    }&#10;&#10;    // Open root directory&#10;    File root = SD.open(&quot;/&quot;);&#10;    if (!root) {&#10;        Serial.println(&quot;Failed to open root directory&quot;);&#10;        fileNames[0] = &quot;Directory Error&quot;;&#10;        fileCount = 1;&#10;        return;&#10;    }&#10;&#10;    // Scan files in root directory&#10;    File file = root.openNextFile();&#10;    while (file &amp;&amp; fileCount &lt; 50) {&#10;        if (!file.isDirectory()) {&#10;            fileNames[fileCount] = String(file.name());&#10;            Serial.println(&quot;Found file: &quot; + fileNames[fileCount]);&#10;            fileCount++;&#10;        }&#10;        file = root.openNextFile();&#10;    }&#10;&#10;    if (fileCount == 0) {&#10;        fileNames[0] = &quot;No files found&quot;;&#10;        fileCount = 1;&#10;    }&#10;&#10;    root.close();&#10;}&#10;&#10;// Event handler for file list items&#10;static void file_list_event_handler(lv_event_t * e) {&#10;    lv_event_code_t code = lv_event_get_code(e);&#10;    lv_obj_t * obj = lv_event_get_target_obj(e);&#10;&#10;    if (code == LV_EVENT_CLICKED) {&#10;        // Get the label from the button and extract filename&#10;        lv_obj_t * label = lv_obj_get_child(obj, 0);&#10;        const char * txt = lv_label_get_text(label);&#10;        Serial.println(&quot;Selected file: &quot; + String(txt));&#10;&#10;        // Here you can add code to handle the selected file&#10;        // For example, play audio file, open file, etc.&#10;    }&#10;}&#10;&#10;void setup() {&#10;    //Some basic info on the Serial console&#10;    Serial.begin(115200);&#10;&#10;    //Initialise the touchscreen&#10;    touchscreenSpi.begin(XPT2046_CLK, XPT2046_MISO, XPT2046_MOSI, XPT2046_CS);&#10;    /* Start second SPI bus for touchscreen */&#10;    touchscreen.begin(touchscreenSpi); /* Touchscreen init */&#10;    touchscreen.setRotation(3); /* Inverted landscape orientation to match screen */&#10;&#10;    //Initialise LVGL&#10;    lv_init();&#10;    draw_buf = new uint8_t[DRAW_BUF_SIZE];&#10;    lv_display_t *disp;&#10;    disp = lv_tft_espi_create(TFT_HOR_RES, TFT_VER_RES, draw_buf, DRAW_BUF_SIZE);&#10;&#10;    //Initialize the XPT2046 input device driver&#10;    indev = lv_indev_create();&#10;    lv_indev_set_type(indev, LV_INDEV_TYPE_POINTER);&#10;    lv_indev_set_read_cb(indev, my_touchpad_read);&#10;&#10;    // Scan SD card for files&#10;    scanSDCard();&#10;&#10;    // Create a scrollable container instead of a list&#10;    file_list = lv_obj_create(lv_screen_active());&#10;    lv_obj_set_size(file_list, 300, 220);  // Set container size to fit screen&#10;    lv_obj_center(file_list);              // Center the container on screen&#10;&#10;    // Enable scrolling&#10;    lv_obj_set_scroll_dir(file_list, LV_DIR_VER);&#10;    lv_obj_set_scrollbar_mode(file_list, LV_SCROLLBAR_MODE_AUTO);&#10;    lv_obj_add_flag(file_list, LV_OBJ_FLAG_SCROLL_ELASTIC);&#10;&#10;    // Set flex layout for vertical arrangement&#10;    lv_obj_set_flex_flow(file_list, LV_FLEX_FLOW_COLUMN);&#10;    lv_obj_set_flex_align(file_list, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);&#10;&#10;    // Add files as individual buttons&#10;    for (int i = 0; i &lt; fileCount; i++) {&#10;        lv_obj_t * btn = lv_button_create(file_list);&#10;        lv_obj_set_size(btn, 280, 40);  // Button size&#10;        lv_obj_add_event_cb(btn, file_list_event_handler, LV_EVENT_ALL, nullptr);&#10;&#10;        // Create label for the file name&#10;        lv_obj_t * label = lv_label_create(btn);&#10;        lv_label_set_text_fmt(label, LV_SYMBOL_FILE &quot; %s&quot;, fileNames[i].c_str());&#10;        lv_obj_center(label);&#10;    }&#10;&#10;    //Done&#10;    Serial.println(&quot;Setup done&quot;);&#10;}&#10;&#10;void loop() {&#10;    lv_tick_inc(millis() - lastTick); //Update the tick timer. Tick is new for LVGL 9&#10;    lastTick = millis();&#10;    lv_timer_handler(); //Update the UI&#10;    delay(5);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>