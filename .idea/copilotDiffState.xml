<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/platformio.ini">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/platformio.ini" />
              <option name="originalContent" value="; PlatformIO Project Configuration File&#10;;&#10;;   Build options: build flags, source filter&#10;;   Upload options: custom upload port, speed and extra flags&#10;;   Library options: dependencies, extra library storages&#10;;   Advanced options: extra scripting&#10;;&#10;; Please visit documentation for the other options and examples&#10;; https://docs.platformio.org/page/projectconf.html&#10;&#10;[env:esp32dev]&#10;platform = espressif32&#10;board = esp32dev&#10;framework = arduino&#10;lib_extra_dirs = lib&#10;monitor_speed = 115200&#10;test_ignore = test_disabled&#10;lib_deps =&#10;    SD&#10;    FS&#10;    SPI&#10;" />
              <option name="updatedContent" value="; PlatformIO Project Configuration File&#10;;&#10;;   Build options: build flags, source filter&#10;;   Upload options: custom upload port, speed and extra flags&#10;;   Library options: dependencies, extra library storages&#10;;   Advanced options: extra scripting&#10;;&#10;; Please visit documentation for the other options and examples&#10;; https://docs.platformio.org/page/projectconf.html&#10;&#10;[env:esp32dev]&#10;platform = espressif32&#10;board = esp32dev&#10;framework = arduino&#10;lib_extra_dirs = lib&#10;monitor_speed = 115200&#10;test_ignore = test_disabled&#10;lib_deps =&#10;    SD&#10;    FS&#10;    SPI&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main.cpp" />
              <option name="originalContent" value="/* Using LVGL with Arduino requires some extra steps...&#10; *&#10; * Be sure to read the docs here: https://docs.lvgl.io/master/integration/framework/arduino.html&#10; * but note you should use the lv_conf.h from the repo as it is pre-edited to work.&#10; *&#10; * You can always edit your own lv_conf.h later and exclude the example options once the build environment is working.&#10; *&#10; * Note you MUST move the 'examples' and 'demos' folders into the 'src' folder inside the lvgl library folder&#10; * otherwise this will not compile, please see README.md in the repo.&#10; *&#10; */&#10;&#10;// TODO:&#10;// https://github.com/witnessmenow/ESP32-Cheap-Yellow-Display/blob/main/TROUBLESHOOTING.md#display-touch-and-sd-card-are-not-working-at-the-same-time&#10;&#10;#include &lt;Arduino.h&gt;&#10;#include &lt;lvgl.h&gt;&#10;#include &lt;TFT_eSPI.h&gt;&#10;#include &lt;XPT2046_Bitbang.h&gt;&#10;#include &lt;SD.h&gt;&#10;#include &lt;FS.h&gt;&#10;&#10;// A library for interfacing with the touch screen using software SPI&#10;//&#10;// Can be installed from the library manager (Search for &quot;XPT2046 Slim&quot;)&#10;// https://github.com/TheNitek/XPT2046_Bitbang_Arduino_Library&#10;// ----------------------------&#10;// Touch Screen pins&#10;// ----------------------------&#10;&#10;// The CYD touch uses some non default&#10;// SPI pins&#10;&#10;#define XPT2046_IRQ 36&#10;#define XPT2046_MOSI 32&#10;#define XPT2046_MISO 39&#10;#define XPT2046_CLK 25&#10;#define XPT2046_CS 33&#10;&#10;// SD Card pin for ESP32-2432S028R&#10;#define SD_CS 5&#10;&#10;XPT2046_Bitbang touchscreen(XPT2046_MOSI, XPT2046_MISO, XPT2046_CLK, XPT2046_CS);&#10;// Updated calibration values based on actual touch data&#10;uint16_t touchScreenMinimumX = 21, touchScreenMaximumX = 295, touchScreenMinimumY = 20, touchScreenMaximumY = 219;&#10;&#10;/*Set to your screen resolution*/&#10;#define TFT_HOR_RES   320&#10;#define TFT_VER_RES   240&#10;&#10;/*LVGL draw into this buffer, 1/10 screen size usually works well. The size is in bytes*/&#10;#define DRAW_BUF_SIZE (TFT_HOR_RES * TFT_VER_RES / 10 * (LV_COLOR_DEPTH / 8))&#10;&#10;#if LV_USE_LOG != 0&#10;void my_print( lv_log_level_t level, const char * buf )&#10;{&#10;    LV_UNUSED(level);&#10;    Serial.println(buf);&#10;    Serial.flush();&#10;}&#10;#endif&#10;&#10;/* LVGL calls it when a rendered image needs to copied to the display*/&#10;void my_disp_flush(lv_display_t *disp, const lv_area_t *area, uint8_t *px_map) {&#10;    /*Call it to tell LVGL you are ready*/&#10;    lv_disp_flush_ready(disp);&#10;}&#10;&#10;/*Read the touchpad*/&#10;void my_touchpad_read(lv_indev_t *indev, lv_indev_data_t *data) {&#10;    TouchPoint p = touchscreen.getTouch();&#10;    if (p.zRaw &gt; 0) {&#10;        //Map this to the pixel position and invert both X and Y coordinates&#10;        data-&gt;point.x = map(p.x, touchScreenMinimumX, touchScreenMaximumX, TFT_HOR_RES, 1);&#10;        data-&gt;point.y = map(p.y, touchScreenMinimumY, touchScreenMaximumY, TFT_VER_RES, 1);&#10;&#10;        data-&gt;state = LV_INDEV_STATE_PRESSED;&#10;&#10;        /*&#10;        Serial.print(&quot;Touch raw x: &quot;);&#10;        Serial.print(p.x);&#10;        Serial.print(&quot; y: &quot;);&#10;        Serial.print(p.y);&#10;        Serial.print(&quot; -&gt; mapped x: &quot;);&#10;        Serial.print(data-&gt;point.x);&#10;        Serial.print(&quot; y: &quot;);&#10;        Serial.println(data-&gt;point.y);&#10;        */&#10;&#10;    } else {&#10;        data-&gt;state = LV_INDEV_STATE_RELEASED;&#10;    }&#10;}&#10;&#10;lv_indev_t *indev; //Touchscreen input device&#10;uint8_t *draw_buf; //draw_buf is allocated on heap otherwise the static area is too big on ESP32 at compile&#10;uint32_t lastTick = 0; //Used to track the tick timer&#10;&#10;// Global variables for file list&#10;lv_obj_t * file_list;&#10;String fileNames[50]; // Store up to 50 files&#10;int fileCount = 0;&#10;&#10;// Function to scan SD card root directory for files&#10;void scanSDCard() {&#10;    fileCount = 0;&#10;&#10;    // Initialize SD card using VSPI (same as the working example)&#10;    SPIClass spi = SPIClass(VSPI);&#10;&#10;    if (!SD.begin(SS, spi, 80000000)) {&#10;        Serial.println(&quot;SD Card initialization failed!&quot;);&#10;        fileNames[0] = &quot;SD Card Error&quot;;&#10;        fileCount = 1;&#10;        return;&#10;    }&#10;&#10;    Serial.println(&quot;SD Card initialized successfully&quot;);&#10;&#10;    // Check card type&#10;    uint8_t cardType = SD.cardType();&#10;    if (cardType == CARD_NONE) {&#10;        Serial.println(&quot;No SD card attached&quot;);&#10;        fileNames[0] = &quot;No SD Card&quot;;&#10;        fileCount = 1;&#10;        return;&#10;    }&#10;&#10;    // Open root directory&#10;    File root = SD.open(&quot;/&quot;);&#10;    if (!root) {&#10;        Serial.println(&quot;Failed to open root directory&quot;);&#10;        fileNames[0] = &quot;Directory Error&quot;;&#10;        fileCount = 1;&#10;        return;&#10;    }&#10;&#10;    // Scan files in root directory&#10;    File file = root.openNextFile();&#10;    while (file &amp;&amp; fileCount &lt; 50) {&#10;        if (!file.isDirectory()) {&#10;            fileNames[fileCount] = String(file.name());&#10;            Serial.println(&quot;Found file: &quot; + fileNames[fileCount]);&#10;            fileCount++;&#10;        }&#10;        file = root.openNextFile();&#10;    }&#10;&#10;    if (fileCount == 0) {&#10;        fileNames[0] = &quot;No files found&quot;;&#10;        fileCount = 1;&#10;    }&#10;&#10;    root.close();&#10;}&#10;&#10;// Event handler for file list items&#10;static void file_list_event_handler(lv_event_t * e) {&#10;    lv_event_code_t code = lv_event_get_code(e);&#10;    lv_obj_t * obj = lv_event_get_target_obj(e);&#10;&#10;    if (code == LV_EVENT_CLICKED) {&#10;        // Get the label from the button and extract filename&#10;        lv_obj_t * label = lv_obj_get_child(obj, 0);&#10;        const char * txt = lv_label_get_text(label);&#10;        Serial.println(&quot;Selected file: &quot; + String(txt));&#10;&#10;        // Here you can add code to handle the selected file&#10;        // For example, play audio file, open file, etc.&#10;    }&#10;}&#10;&#10;void setup() {&#10;    //Some basic info on the Serial console&#10;    Serial.begin(115200);&#10;&#10;    //Initialise the touchscreen using software SPI&#10;    touchscreen.begin(); /* Touchscreen init */&#10;&#10;    //Initialise LVGL&#10;    lv_init();&#10;    draw_buf = new uint8_t[DRAW_BUF_SIZE];&#10;    lv_display_t *disp;&#10;    disp = lv_tft_espi_create(TFT_HOR_RES, TFT_VER_RES, draw_buf, DRAW_BUF_SIZE);&#10;&#10;    //Initialize the XPT2046 input device driver&#10;    indev = lv_indev_create();&#10;    lv_indev_set_type(indev, LV_INDEV_TYPE_POINTER);&#10;    lv_indev_set_read_cb(indev, my_touchpad_read);&#10;&#10;    // Scan SD card for files&#10;    scanSDCard();&#10;&#10;    // Create a scrollable container instead of a list&#10;    file_list = lv_obj_create(lv_screen_active());&#10;    lv_obj_set_size(file_list, 300, 220);  // Set container size to fit screen&#10;    lv_obj_center(file_list);              // Center the container on screen&#10;&#10;    // Enable scrolling&#10;    lv_obj_set_scroll_dir(file_list, LV_DIR_VER);&#10;    lv_obj_set_scrollbar_mode(file_list, LV_SCROLLBAR_MODE_AUTO);&#10;    lv_obj_add_flag(file_list, LV_OBJ_FLAG_SCROLL_ELASTIC);&#10;&#10;    // Set flex layout for vertical arrangement&#10;    lv_obj_set_flex_flow(file_list, LV_FLEX_FLOW_COLUMN);&#10;    lv_obj_set_flex_align(file_list, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);&#10;&#10;    // Add files as individual buttons&#10;    for (int i = 0; i &lt; fileCount; i++) {&#10;        lv_obj_t * btn = lv_button_create(file_list);&#10;        lv_obj_set_size(btn, 280, 40);  // Button size&#10;        lv_obj_add_event_cb(btn, file_list_event_handler, LV_EVENT_ALL, nullptr);&#10;&#10;        // Create label for the file name&#10;        lv_obj_t * label = lv_label_create(btn);&#10;        lv_label_set_text_fmt(label, LV_SYMBOL_FILE &quot; %s&quot;, fileNames[i].c_str());&#10;        lv_obj_center(label);&#10;    }&#10;&#10;    //Done&#10;    Serial.println(&quot;Setup done&quot;);&#10;}&#10;&#10;void loop() {&#10;    lv_tick_inc(millis() - lastTick); //Update the tick timer. Tick is new for LVGL 9&#10;    lastTick = millis();&#10;    lv_timer_handler(); //Update the UI&#10;    delay(5);&#10;}" />
              <option name="updatedContent" value="/* &#10; * CYD Soundboard - ESP32 Cheap Yellow Display File Browser&#10; * &#10; * This project creates a file browser interface on the ESP32-2432S028R (CYD)&#10; * using LVGL for the UI, with support for display, touch, and SD card.&#10; * &#10; * Hardware used:&#10; * - ESP32-2432S028R (Cheap Yellow Display)&#10; * - 320x240 TFT display with ILI9341 driver&#10; * - XPT2046 resistive touch controller&#10; * - MicroSD card slot&#10; */&#10;&#10;#include &lt;Arduino.h&gt;&#10;#include &lt;lvgl.h&gt;&#10;#include &lt;TFT_eSPI.h&gt;&#10;#include &lt;XPT2046_Bitbang.h&gt;&#10;#include &lt;SD.h&gt;&#10;#include &lt;FS.h&gt;&#10;&#10;// Pin definitions for CYD hardware&#10;#define XPT2046_IRQ 36&#10;#define XPT2046_MOSI 32&#10;#define XPT2046_MISO 39&#10;#define XPT2046_CLK 25&#10;#define XPT2046_CS 33&#10;#define SD_CS 5&#10;&#10;// Display configuration&#10;#define TFT_HOR_RES   320&#10;#define TFT_VER_RES   240&#10;#define DRAW_BUF_SIZE (TFT_HOR_RES * TFT_VER_RES / 10 * (LV_COLOR_DEPTH / 8))&#10;&#10;// Touch screen setup using software SPI to avoid conflicts&#10;XPT2046_Bitbang touchscreen(XPT2046_MOSI, XPT2046_MISO, XPT2046_CLK, XPT2046_CS);&#10;&#10;// Touch calibration values (determined from actual hardware testing)&#10;uint16_t touchScreenMinimumX = 21, touchScreenMaximumX = 295;&#10;uint16_t touchScreenMinimumY = 20, touchScreenMaximumY = 219;&#10;&#10;// LVGL variables&#10;lv_indev_t *indev;        // Touch input device&#10;uint8_t *draw_buf;        // Display buffer&#10;uint32_t lastTick = 0;    // Timer for LVGL&#10;&#10;// File browser variables&#10;lv_obj_t * file_list;     // Container for file buttons&#10;String fileNames[50];     // Array to store file names&#10;int fileCount = 0;        // Number of files found&#10;&#10;#if LV_USE_LOG != 0&#10;void my_print( lv_log_level_t level, const char * buf )&#10;{&#10;    LV_UNUSED(level);&#10;    Serial.println(buf);&#10;    Serial.flush();&#10;}&#10;#endif&#10;&#10;/* LVGL display flush callback - required but handled by TFT_eSPI integration */&#10;void my_disp_flush(lv_display_t *disp, const lv_area_t *area, uint8_t *px_map) {&#10;    lv_disp_flush_ready(disp);&#10;}&#10;&#10;/* Read touch input and convert to screen coordinates */&#10;void my_touchpad_read(lv_indev_t *indev, lv_indev_data_t *data) {&#10;    TouchPoint p = touchscreen.getTouch();&#10;    &#10;    if (p.zRaw &gt; 0) {  // Touch detected&#10;        // Map raw touch coordinates to screen pixels&#10;        // Note: Coordinates are inverted to match upside-down display&#10;        data-&gt;point.x = map(p.x, touchScreenMinimumX, touchScreenMaximumX, TFT_HOR_RES, 1);&#10;        data-&gt;point.y = map(p.y, touchScreenMinimumY, touchScreenMaximumY, TFT_VER_RES, 1);&#10;        data-&gt;state = LV_INDEV_STATE_PRESSED;&#10;    } else {&#10;        data-&gt;state = LV_INDEV_STATE_RELEASED;&#10;    }&#10;}&#10;&#10;/* Scan SD card root directory and populate file list */&#10;void scanSDCard() {&#10;    fileCount = 0;&#10;    &#10;    // Initialize SD card on VSPI bus&#10;    SPIClass spi = SPIClass(VSPI);&#10;    if (!SD.begin(SD_CS, spi, 80000000)) {&#10;        Serial.println(&quot;SD Card initialization failed!&quot;);&#10;        fileNames[0] = &quot;SD Card Error&quot;;&#10;        fileCount = 1;&#10;        return;&#10;    }&#10;&#10;    Serial.println(&quot;SD Card initialized successfully&quot;);&#10;&#10;    // Check if card is present&#10;    uint8_t cardType = SD.cardType();&#10;    if (cardType == CARD_NONE) {&#10;        Serial.println(&quot;No SD card attached&quot;);&#10;        fileNames[0] = &quot;No SD Card&quot;;&#10;        fileCount = 1;&#10;        return;&#10;    }&#10;&#10;    // Open root directory and scan for files&#10;    File root = SD.open(&quot;/&quot;);&#10;    if (!root) {&#10;        Serial.println(&quot;Failed to open root directory&quot;);&#10;        fileNames[0] = &quot;Directory Error&quot;;&#10;        fileCount = 1;&#10;        return;&#10;    }&#10;&#10;    // Read all files in root directory&#10;    File file = root.openNextFile();&#10;    while (file &amp;&amp; fileCount &lt; 50) {&#10;        if (!file.isDirectory()) {&#10;            fileNames[fileCount] = String(file.name());&#10;            Serial.println(&quot;Found file: &quot; + fileNames[fileCount]);&#10;            fileCount++;&#10;        }&#10;        file = root.openNextFile();&#10;    }&#10;&#10;    if (fileCount == 0) {&#10;        fileNames[0] = &quot;No files found&quot;;&#10;        fileCount = 1;&#10;    }&#10;&#10;    root.close();&#10;}&#10;&#10;/* Handle button clicks on file list items */&#10;static void file_list_event_handler(lv_event_t * e) {&#10;    lv_event_code_t code = lv_event_get_code(e);&#10;    lv_obj_t * obj = lv_event_get_target_obj(e);&#10;&#10;    if (code == LV_EVENT_CLICKED) {&#10;        // Get filename from button label&#10;        lv_obj_t * label = lv_obj_get_child(obj, 0);&#10;        const char * txt = lv_label_get_text(label);&#10;        Serial.println(&quot;Selected file: &quot; + String(txt));&#10;        &#10;        // TODO: Add file handling logic here (play audio, etc.)&#10;    }&#10;}&#10;&#10;void setup() {&#10;    Serial.begin(115200);&#10;    Serial.println(&quot;CYD Soundboard starting...&quot;);&#10;&#10;    // Initialize touch screen (uses software SPI)&#10;    touchscreen.begin();&#10;&#10;    // Initialize LVGL graphics library&#10;    lv_init();&#10;    draw_buf = new uint8_t[DRAW_BUF_SIZE];&#10;    lv_display_t *disp = lv_tft_espi_create(TFT_HOR_RES, TFT_VER_RES, draw_buf, DRAW_BUF_SIZE);&#10;&#10;    // Setup touch input device&#10;    indev = lv_indev_create();&#10;    lv_indev_set_type(indev, LV_INDEV_TYPE_POINTER);&#10;    lv_indev_set_read_cb(indev, my_touchpad_read);&#10;&#10;    // Scan SD card for files&#10;    scanSDCard();&#10;&#10;    // Create scrollable file list container&#10;    file_list = lv_obj_create(lv_screen_active());&#10;    lv_obj_set_size(file_list, 300, 220);&#10;    lv_obj_center(file_list);&#10;&#10;    // Configure scrolling behavior&#10;    lv_obj_set_scroll_dir(file_list, LV_DIR_VER);&#10;    lv_obj_set_scrollbar_mode(file_list, LV_SCROLLBAR_MODE_AUTO);&#10;    lv_obj_add_flag(file_list, LV_OBJ_FLAG_SCROLL_ELASTIC);&#10;&#10;    // Arrange items vertically&#10;    lv_obj_set_flex_flow(file_list, LV_FLEX_FLOW_COLUMN);&#10;    lv_obj_set_flex_align(file_list, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);&#10;&#10;    // Create a button for each file found&#10;    for (int i = 0; i &lt; fileCount; i++) {&#10;        lv_obj_t * btn = lv_button_create(file_list);&#10;        lv_obj_set_size(btn, 280, 40);&#10;        lv_obj_add_event_cb(btn, file_list_event_handler, LV_EVENT_ALL, nullptr);&#10;&#10;        // Add file icon and name to button&#10;        lv_obj_t * label = lv_label_create(btn);&#10;        lv_label_set_text_fmt(label, LV_SYMBOL_FILE &quot; %s&quot;, fileNames[i].c_str());&#10;        lv_obj_center(label);&#10;    }&#10;&#10;    Serial.println(&quot;Setup complete!&quot;);&#10;}&#10;&#10;void loop() {&#10;    // Update LVGL timing and process UI events&#10;    lv_tick_inc(millis() - lastTick);&#10;    lastTick = millis();&#10;    lv_timer_handler();&#10;    delay(5);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>